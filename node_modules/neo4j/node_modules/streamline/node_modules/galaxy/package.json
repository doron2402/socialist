{
  "name": "galaxy",
  "description": "Cosmic harmony with callbacks and generators",
  "version": "0.1.7",
  "repository": {
    "type": "git",
    "url": "git://github.com/bjouhier/galaxy.git"
  },
  "engines": {
    "node": ">=0.11.10"
  },
  "dependencies": {},
  "author": {
    "name": "Bruno Jouhier"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "index.js",
  "readme": "Galaxy brings `async/await` semantics to JavaScript with a minimal API, thanks to EcmaScript 6 generators.\n\n## async/await in JavaScript\n\nGalaxy lets you write async code as if JavaScript had [`async/await` keywords](http://msdn.microsoft.com/en-us/library/vstudio/hh191443.aspx).\n\nFor example, here is how you would write an async function that counts lines in a file:\n\n``` javascript\nfunction* countLines(path) {\n\tvar names = yield fs.readdir(path);\n\tvar total = 0;\n\tfor (var i = 0; i < names.length; i++) {\n\t\tvar fullname = path + '/' + names[i];\n\t\tif ((yield fs.stat(fullname)).isDirectory()) {\n\t\t\ttotal += yield countLines(fullname);\n\t\t} else {\n\t\t\tvar count = (yield fs.readFile(fullname, 'utf8')).split('\\n').length;\n\t\t\tconsole.log(fullname + ': ' + count);\n\t\t\ttotal += count;\n\t\t}\n\t}\n\treturn total;\n}\n```\n\nJust think of the `*` in `function*` as an `async` keyword and of `yield` as an `await` keyword.\n\nYou can write another async function that calls `countLines`:\n\n``` javascript\nfunction* projectLineCounts() {\n\tvar total = 0;\n\ttotal += yield countLines(__dirname + '/../examples');\n\ttotal += yield countLines(__dirname + '/../lib');\n\ttotal += yield countLines(__dirname + '/../test');\n\tconsole.log('TOTAL: ' + total);\n\treturn total;\n}\n```\n\nNote: don't forget to prefix all the async calls with a `yield`. Otherwise you will be adding _generator_ objects to `total` and you'll just get a `NaN`.\n\nCool! But where does galaxy come into play? This is just plain JavaScript (with ES6 generators) and there are no calls to any `galaxy` API. Pretty mysterious!\n\nThat's the whole point behind galaxy: you hardly see it. It lets you write async functions that call other async functions with `function*` and `yield`. There are no extra API calls. Exactly like you would write your code if the language had `async/await` keywords.\n\n## star/unstar\n\nThe magic happens in two places: when you call node.js async functions, and when node.js calls your async functions.\n\nThe node.js functions that we called in the example functions are `fs.readdir` and `fs.readFile`. Part of the magic is that `fs` is not your usual `require('fs')`. It is initialized as:\n\n``` javascript\nvar galaxy = require('galaxy');\nvar fs = galaxy.star(require('fs'));\n```\n\nThe `galaxy.star` call returns a module in which all the asynchronous functions have been _starred_, i.e. promoted from `function` to `function*`. When you call these functions with `yield` you get `await` semantics.\n\nNote that `galaxy.star` can also be applied to individual functions. So, instead of _starring_ the entire `fs` module, we could have starred individual functions:\n\n``` javascript\nvar galaxy = require('galaxy');\nvar fs = require('fs');\nvar readdir = galaxy.star(fs.readdir);\nvar readFile = galaxy.star(fs.readFile);\n```\n\n---\n\nThe other side of the magic happens when node.js calls your `function*` APIs. In our example, this happens when we call `projectLineCounts`, our main function. Here is the code:\n\n``` javascript\nvar projectLineCountsCb = galaxy.unstar(projectLineCounts);\n\nprojectLineCountsCb(function(err, result) {\n\tif (err) throw err;\n\tconsole.log('CALLBACK RESULT: ' + result);\n});\n```\n\nThe `galaxy.unstar` call converts our `function*` into a regular node.js `function` that we then call with a callback.\n\n`galaxy.unstar` can also be applied to a whole module, in which case it _unstars_ all the functions of the module. This is handy if you have written a library with galaxy and you want to make it available to developers who write their code in callback style. Just create another module that exports the _unstarred_ version of your functions:\n\n``` javascript\nvar galaxy = require('galaxy');\nmodule.exports = galaxy.unstar(require('my-starred-functions'));\n```\n\nTogether, `galaxy.star` and `galaxy.unstar` take care of all the ugly work to make `*/yield` behave like `async/await`.\n\n## Parallelizing\n\nFine. But all the code that we have seen above is completely sequential. Would be nice if we could parallelize some calls.\n\nThis is actually not very difficult: instead of _yielding_ on a generator returned by a _starred_ function you can _spin_ on it. This runs the generator in parallel with your other code and it gives you back a future. The future that you obtain is just another _starred_ function on which you can _yield_ later to get the result of the computation.\n\nSo, for example, you can parallelize the `projectLineCounts` operation by rewriting it as:\n\n``` javascript\nfunction* projectLineCountsParallel() {\n \tvar future1 = galaxy.spin(countLines(__dirname + '/../examples'));\n \tvar future2 = galaxy.spin(countLines(__dirname + '/../lib'));\n\tvar future3 = galaxy.spin(countLines(__dirname + '/../test'));\n \tvar total = (yield future1()) + (yield future2()) + (yield future3());\n\tconsole.log('TOTAL: ' + total);\n\treturn total; \n}\n```\n\nNote: this is not true parallelism; the futures only move forwards when execution reaches `yield` keywords in your code.\n\nGalaxy also provides a `funnel` call that you can use to limit the level of parallelism on a given block of code. By setting the funnel's size to 1 you can set up critical sections. See the [galaxy API](https://github.com/bjouhier/galaxy/blob/master/lib/galaxy.md) for details.\n\n## Array utilities\n\nGalaxy provides async variants of the EcmaScript 5 array functions (`forEach`, `map`, `filter`, ...). These variants give you the choice between sequential and parallel execution when relevant.\n\nSee [API documentation](https://github.com/bjouhier/galaxy/blob/master/lib/array.md) for details.\n\n## Exception Handling\n\nThe usual exception handling keywords (`try/catch/finally/throw`) work as you would expect them to.\n\nIf an exception is thrown during the excution of a future, it is thrown when you _yield_ on the future, not when you create it with `galaxy.spin`.\n\n## Long stacktrace\n\nGalaxy provides long stacktraces. Here is a typical stacktrace:\n\n```\nError: getaddrinfo ENOTFOUND\n    <<< yield stack >>>\n    at googleSearch (/Users/bruno/dev/syracuse/node_modules/galaxy/tutorial/tuto6-mongo.js:43:11)\n    at search (/Users/bruno/dev/syracuse/node_modules/galaxy/tutorial/tuto6-mongo.js:30:34)\n    at  (/Users/bruno/dev/syracuse/node_modules/galaxy/tutorial/tuto6-mongo.js:22:29)\n    <<< raw stack >>>\n    at errnoException (dns.js:37:11)\n    at Object.onanswer [as oncomplete] (dns.js:124:16)\n```\n\nThe `<<< yield stack >>>` part is a stack which has been reconstructed by the galaxy library and which reflects the stack of `yield` calls in your code. \n\nThe `<<< raw stack >>>` part gives you the low level callback stack that triggered the exception. It is usually a lot less helpful than the _yield_ stack because it does not give you much context about the error.\n\nThis feature requires that you install the [galaxy-stack](https://github.com/bjouhier/galaxy-stack) addon module:\n\n```\nnpm install galaxy-stack\n```\n\n## Stable context\n\nGlobal variables are evil. Everyone knows that!\n\nBut there are a few cases where they can be helpful. \nThe main one is to track information about _who_ is executing the current request: security context, locale, etc. This kind of information is usually very stable (for a given request) and it would be very heavy to pass it explicitly down to all the low level APIs that need it. So the best way is to pass it implicitly through some kind of global context.\n\nBut you need a special global which is preserved across _yield_ points. If you set it at the beginning of a request it should remain the same throughout the request (unless you change it explicitly). It should not change under your feet because other requests with different contexts get interleaved.\n\nGalaxy exposes a `context` property that is guaranteed to be stable across yield points. If you assign an object to `galaxy.context` at the beginning of a request, you can retrieve it later.\n\nNote: this functionality is more or less equivalent to Thread Local Storage (TLS) in threaded systems.\n\n## Odd callbacks\n\nGalaxy is designed to work with functions that have the usual node.js callback signature: `callback(err, result)`. It also works with functions that return several results through their callback. In this case the results are returned as an array. For example:\n\n``` javascript\nvar request = require('request');\n// request.get calls its callback as callback(err, response, body)\n\nvar get = galaxy.star(request.get);\nvar r = yield get(url);\n// the starred version returns [response, body]\nconsole.log(\"status=\" + r[0].statusCode);\nconsole.log(\"body=\" + r[1]);\n```\n\nOn the other hand, galaxy cannot deal directly with functions that have an odd callback signature. The best example is `fs.exists` which does not have any error parameter in its callback. You need a special wrapper to deal with such calls:\n\n```\n// the wrapper\nfunction existsWrapper(path, cb) {\n\tfs.exists(path, function(result) { cb(null, result); })\n}\n\nvar exists = galaxy.star(existsWrapper);\nvar found = yield exists(__dirname + '/README.md');\n```\n\n## Streams\n\nGalaxy provides a simple API to deal with node.js streams. This API is packaged as a separate [galaxy-streams](https://github.com/bjouhier/galaxy-streams) package.\n\n## Asynchronous constructor\n\nGalaxy also lets you invoke constructors that contain asynchronous calls but this is one of the rare cases where you cannot just use the usual JavaScript keyword. Instead of the `new` keyword you use the special `galaxy.new` helper. Here is an example:\n\n``` javascript\n// asynchronous constructor\nfunction* MyClass(name) {\n\tthis.name = name;\n\tyield myAsyncFn();\n}\n\n// create an instance of MyClass\nvar myObj = (yield galaxy.new(MyClass)(\"obj1\"));\nconsole.log(myObj.name);\n```\n\n## API\n\nSee [API.md](API.md)\n\nSee also the [tutorial](tutorial/tutorial.md) and the [examples](examples).\n\n## Installation\n\n``` sh\n$ npm install galaxy\n$ npm install galaxy-stack\n```\n\n`galaxy-stack` is an optional module that you should install to get long stacktraces.\n\nThen you can try the examples:\n\n``` sh\n$ cd node_modules/galaxy\n$ node --harmony examples/countLines\n... some output ...\n$ node --harmony examples/countLinesParallel\n... slightly different output  ...\n```\n\n## Running in the browser\n\nGalaxy also runs browser side but you need a bleeding edge browser like the latest Google Chrome Canary that you can download from https://www.google.com/intl/en/chrome/browser/canary.html. \n\nHarmony generators are not turned on by default but the procedure to enable them is easy: open the chrome://flags page then check the \"Enable Experimental JavaScript\" option and restart Canary. You're all set and you can open the examples/hello-browser.html page to see Galaxy in action. Pretty boring demo but at least it works!\n\n## Gotchas\n\nGenerators have been added very recently to V8. To use them you need to:\n\n* Install node.js version 0.11.2 (unstable) or higher.\n* Run node with the `--harmony` flag.\n\nFor example, to run the example above:\n\n``` sh\n$ node -v\nv0.11.2\n$ node --harmony examples/countLines\n```\n\nThe yield keyword can be tricky because it has a very low precedence. For example you cannot write:\n\n``` javascript\nvar sum1 = yield a() + yield b();\nvar sum2 = yield c() + 3;\n```\n\nbecause they get interpreted as:\n\n``` javascript\nvar sum1 = yield (a() + yield b()); // compile error\nvar sum2 = yield (c() + 3); // galaxy gives runtime error\n```\n\nYou have to write:\n\n``` javascript\nvar sum = (yield a()) + (yield b());\nvar sum2 = (yield c()) + 3;\n```\n\nThis brings a little lispish flavor to your JS code.\n\n\n## More info\n\nThis design is strongly inspired from bits and pieces of [streamline.js](https://github.com/Sage/streamlinejs). The following blog articles (some a bit old) give background information on this design:\n\n* [bringing async/await to life in JavaScript](http://bjouhier.wordpress.com/2013/06/01/bringing-asyncawait-to-life-in-javascript/)\n* [an early experiment with generators](http://bjouhier.wordpress.com/2012/05/18/asynchronous-javascript-with-generators-an-experiment/).\n* [futures = currying the callback](http://bjouhier.wordpress.com/2011/04/04/currying-the-callback-or-the-essence-of-futures/)\n* [stream API: events or callbacks](http://bjouhier.wordpress.com/2012/07/04/node-js-stream-api-events-or-callbacks/)\n\nThe streamline.js tool has been adapted to generate `galaxy` code in `--generators` mode. So, you can also use streamline.js as a preprocessor to generate `galaxy` code.\n\n## License\n\nThis work is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bjouhier/galaxy/issues"
  },
  "homepage": "https://github.com/bjouhier/galaxy",
  "_id": "galaxy@0.1.7",
  "dist": {
    "shasum": "c3125ac987dace1d9492c5c480c5603b152ffd34"
  },
  "_from": "galaxy@^0.1.6",
  "_resolved": "https://registry.npmjs.org/galaxy/-/galaxy-0.1.7.tgz"
}
