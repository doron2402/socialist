{
  "name": "streamline",
  "description": "Asynchronous Javascript for dummies",
  "version": "0.10.12",
  "homepage": "http://github.com/Sage/streamlinejs",
  "repository": {
    "type": "git",
    "url": "git://github.com/Sage/streamlinejs.git"
  },
  "engines": {
    "node": ">=0.6.0"
  },
  "dependencies": {
    "source-map": "~0.1.27",
    "fibers": "^1.0.1",
    "galaxy": "^0.1.6"
  },
  "optionalDependencies": {
    "fibers": "^1.0.1",
    "galaxy": "^0.1.6"
  },
  "author": {
    "name": "Bruno Jouhier"
  },
  "directories": {
    "lib": "./lib",
    "bin": "./bin"
  },
  "main": "index.js",
  "bin": {
    "_coffee": "bin/_coffee",
    "_node": "bin/_node"
  },
  "contributors": [
    {
      "name": "Bruno Jouhier",
      "email": "bruno.jouhier@sage.com"
    },
    {
      "name": "Preston Guillory",
      "email": "pguillory@gmail.com"
    },
    {
      "name": "Will Conant",
      "email": "will.conant@gmail.com"
    },
    {
      "name": "Aseem Kishore",
      "email": "aseem.kishore@gmail.com"
    },
    {
      "name": "Daniel Ennis",
      "email": "aikar@aikar.co"
    },
    {
      "name": "Marcel Laverdet",
      "email": "marcel@laverdet.com",
      "url": "https://github.com/laverdet/"
    },
    {
      "name": "Evan Worley"
    },
    {
      "name": "anodos",
      "url": "https://github.com/anodos"
    },
    {
      "name": "Alan Gutierrez",
      "email": "alan@prettyrobots.com"
    },
    {
      "name": "Geoffry Song",
      "email": "goffrie@gmail.com"
    }
  ],
  "readme": "# streamline.js\n\n`streamline.js` is a language tool to simplify asynchronous Javascript programming.\n\nInstead of writing hairy code like:\n\n```javascript\nfunction archiveOrders(date, cb) {\n  db.connect(function(err, conn) {\n    if (err) return cb(err);\n    conn.query(\"select * from orders where date < ?\", [date], function(err, orders) {\n      if (err) return cb(err);\n      helper.each(orders, function(order, next) {\n        conn.execute(\"insert into archivedOrders ...\", [order.id, ...], function(err) {\n          if (err) return cb(err);\n          conn.execute(\"delete from orders where id=?\", [order.id], function(err) {\n            if (err) return cb(err);\n            next();\n          });\n        });\n      }, function() {\n        console.log(\"orders have been archived\");\n        cb();\n      });\n    });\n  });\n}\n```\n\nyou write:\n\n```javascript\nfunction archiveOrders(date, _) {\n  var conn = db.connect(_);\n  conn.query(\"select * from orders where date < ?\", [date], _).forEach_(_, function(_, order) {\n    conn.execute(\"insert into archivedOrders ...\", [order.id, ...], _);\n    conn.execute(\"delete from orders where id=?\", [order.id], _);\n  });\n  console.log(\"orders have been archived\");\n}\n```\n\nand streamline transforms the code and takes care of the callbacks!\n\nNo control flow APIs to learn! You just have to follow a simple rule:\n\n> Replace all callbacks by an underscore and write your code as if all functions were synchronous.\n\nStreamline is not limited to a subset of Javascript. \nYou can use all the features of Javascript in your asynchronous code: conditionals, \nloops, `try/catch/finally` blocks, anonymous functions, chaining, `this`, etc. \n\nStreamline also provides _futures_, and asynchronous variants of the EcmaScript 5 array functions (`forEach`, `map`, etc.).\n\n<a name=\"installation\">\n# Installation\n\nNPM, of course: \n\n```sh\nnpm install streamline -g\n```\n\n**Warning**: you may get errors when installing streamline versions >= 0.10.11 because fibers and galaxy are now installed as optional packages and they are not compatible with all versions of node.js. But these packages are optional and **streamline itself should install fine**. Just check these dependencies if you plan to use the _fibers_ or _generators_ modes. \n\nThe `-g` option installs streamline _globally_.\nYou can also install it _locally_, without `-g` but then the `_node` and `_coffee` \ncommands will not be in your default PATH.\n\nNote: If you encounter a permission error when installing on UNIX systems, you should retry with `sudo`. \n\n<a name=\"cool-demos\">\n# Cool demo\n\nhttp://coolwanglu.github.io/vim.js/web/vim.html (emscripten + streamline.js + @coolwanglu's magic touch).\n\n<a name=\"hello-world\">\n# Hello World\n\nStreamline modules have `._js` or `._coffee` extensions and you run them with the `_node` or `_coffee` \nloader.\n\nJavascripters:\n\n``` sh\n$ cat > hello._js\nconsole.log('hello ...');\nsetTimeout(_, 1000);\nconsole.log('... world');\n^D\n$ _node hello\n```\n\nCoffeescripters:\n\n``` sh\n$ cat > hello._coffee\nconsole.log 'hello ...'\nsetTimeout _, 1000\nconsole.log '... world'\n^D\n$ _coffee hello\n```\n\nYou can also create standalone shell utilities:\n\n``` sh\n$ cat > hello._js\n#!/usr/bin/env _node\nconsole.log('hello ...');\nsetTimeout(_, 1000);\nconsole.log('... world');\n^D\n$ chmod +x hello._js\n$ ./hello._js\n```\n\nor:\n\n``` sh\n$ cat > hello._coffee\n#!/usr/bin/env _coffee\nconsole.log 'hello ...'\nsetTimeout _, 1000\nconsole.log '... world'\n^D\n$ chmod +x hello._coffee\n$ ./hello._coffee\n```\n\n<a name=\"compiling-and-loaders\">\n# Compiling and writing loaders\n\nYou can also set up your code so that it can be run directly with `node` or `coffee`.\nYou have two options here:\n\nThe first one is to compile your source with `_node -c` or `_coffee -c`:\n\n``` sh\n$ _node -c .\n```\n\nThis command compiles all the `*._js` and `*._coffee` source files in the current directory and its sub-directories. It generates `*.js` files that you can run directly with `node`.\n\nThe second one is to create your own loader with the `register` API. See the [loader example](https://github.com/Sage/streamlinejs/blob/master/examples/loader/loader.md) for details.\n\nCompiling will give you the fastest startup time because node will directly load the compiled `*.js` files but the `register` API has a `cache` option which comes close and the loader saves you a compilation pass.\n\n<a name=\"browser\">\n# Browser-side use\n\nYou have three options to use streamline in the browser:\n\n* The first one is to compile the source with `_node --standalone -c`. The compiler generates vanilla Javascript code that you can load with `<script>` directives in an HTML page. See the [eval unit test](https://github.com/Sage/streamlinejs/blob/master/test/common/eval-test.html) for an example.\n* You can also transform the code in the browser with the `transform` API. All the necessary JS code is available as a single `lib/transform-all.js` file. See the [streamlineMe example](https://github.com/Sage/streamlinejs/blob/master/examples/streamlineMe).\n* A third option is to use the [streamline-require](https://github.com/Sage/streamline-require) infrastructure. This is a very efficient browser-side implementation of `require` that lets you load streamlined modules as well as vanilla Javascript modules in the browser. \n\n<a name=\"generation-options\">\n# Generation options\n\nStreamline gives you the choice between generating regular callback-based asynchronous code, \ngenerating code that takes advantage of the [fibers library](https://github.com/laverdet/node-fibers), \nor generating code for [JavaScript generators](https://developer.mozilla.org/en/New_in_JavaScript_1.7#Generators).\n\nThe _callback_ option produces code that does not have any special runtime dependencies. \n\nThe _fibers_ option produces simpler code but requires that you install \nthe fibers library (easy: `npm install fibers`). \nThis option gives superior development experience: line numbers and comments are preserved in the transformed code; \nyou can step with the debugger through asynchronous calls without having to go through complex callbacks, etc.\n\nThe _fibers_ option can be activated by passing the `--fibers` option to the `_node` command or by setting the `fibers` option when registering streamline \n(see the `streamline.register(options)` function.\n\nThe _generators_ option produces code for harmony generators. It uses the [galaxy](https://github.com/bjouhier/galaxy) module as runtime. It requires node.js version >= 0.11.4 or an experimental browser (latest Chrome Canary). This options produces code which is similar to what you get with the fibers option, just a bit heavier because of the `yield` keywords.\n\nThe _generators_ option can be activated by passing the `--generators` option to the `_node` command or by setting the `ganerators` option when registering streamline. If you run it with a loader you have to pass the `--harmony` option to `node`.\n\nThere are also _fast_ variants of the _fibers_ and _generators_ options. See below.\n \n<a name=\"node-compat\">\n# Interoperability with standard node.js code\n\nYou can call standard node functions from streamline code. For example the `fs.readFile` function:\n\n```javascript\nfunction lineCount(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n```\nYou can also call streamline functions as if they were standard node functions. For example, the `lineCount` function defined above can be called as follows from non-streamlined modules:\n\n```javascript\nlineCount(\"README.md\", function(err, result) {\n  if (err) return console.error(\"ERROR: \" + err.message);\n  console.log(\"README has \" + result + \" lines.\");\n});\n```\n\nAnd you can mix streamline functions, classical callback based code and synchrononous functions in the same file. \nStreamline only transforms the functions that have the special `_` parameter. \n\nNote: this works with all transformation options. \nEven if you use the _fibers_ option, you can seamlessly call standard callback based node APIs \nand the asynchronous functions that you create with streamline have the standard node callback signature.\n\n<a name=\"promises\">\n# Interoperability with Promises\n\nStreamline also provides seamless interoperability with Promise libraries, in both directions.\n\nFirst, you can consume promises from streamline code, by passing two underscores to their `then` method:\n\n```\nfunction myStreamlineFunction(p1, p2, _) {\n  var result = functionReturningAPromise(p1, p2).then(_, _);\n  // do something with result\n}\n```\n\nNote: if the promise fails the error will be propagated as an exception and you can catch it with `try/catch`.\n\nAnd you can also consume libraries implemented with streamline as if they had been implemented with promises. All you have to do is omit the `_` parameter when calling streamlined functions and you will get a promise in return.\n\n```\nfunction callingStreamlineAsPromise(p1, p2) {\n  var p = myStreamlineFunction(p1, p2);\n  p.then(function(result) {\n    // do something with result\n  }, function(err) {\n    // handle error\n  });\n}\n```\n\nNote: you can also pass `null` or `undefined` as callback. This is useful when `_` is not the last parameter.\n\nPromise interoperability is **not** enabled by default but you can enable it easily:\n\n* If you start your program with `_node` or `_coffee`, just pass the `--promise` option.\n* If you start it with a loader (see above), just set the `promise` option to `true` in your `streamline.register(options)` call.\n\nStreamline will use the JavaScript built-in `Promise` class by default if available (node v11.13 and up). If this built-in class is not available it will try to load the `es6-promise` module instead (you should install it with `npm install es6-promise`).\n\nNote: the loader also gives you the option to pick a promise library of your choice (but reasonably compliant with ES6 specs). To do this, set the `promise` option to the name of your promise library, instead of `true`.\n\n<a name=\"futures\">\n# Futures\n\nStreamline also provides _futures_. Futures are like promises, without all the bells and whistles. They let you parallelize I/O operations in a very simple manner. They are always bundled with streamline and they have a very simple API.\n\nIf you pass `!_` instead of `_` when calling a streamline function, the function returns a _future_. The _future_ is just a regular node.js asynchronous function that you can call later to obtain the result. Here is an example:\n\n```javascript\nfunction countLines(path, _) {\n  return fs.readFile(path, \"utf8\", _).split('\\n').length;\n}\n\nfunction compareLineCounts(path1, path2, _) {\n  // parallelize the two countLines operations\n  var n1 = countLines(path1, !_);\n  var n2 = countLines(path2, !_);\n  // get the results and diff them\n  return n1(_) - n2(_);\n}\n```\n\nIn this example, `countLines` is called twice with `!_`. These calls start the `fs.readFile` asynchronous operations and return immediately two _futures_ (`n1` and `n2`). The `return` statement retrieves the results with `n1(_)` and `n2(_)` calls and computes their difference. \n\nFutures are very flexible. In the example above, the results are retrieved from the same function, but you can also pass futures to other functions, store them in objects, call them to get the results from a different module, etc. You can also have several readers on the same future. \n\nSee the [futures](https://github.com/Sage/streamlinejs/wiki/Futures) wiki page for details.\n\nThe [flows module](https://github.com/Sage/streamlinejs/blob/master/lib/util/flows.md) contains utilities to deal with futures. For example `flows.collect` to wait on an array of futures and `flows.funnel` to limit the number of concurrent operations.\n\n<a name=\"array-functions\">\n# Asynchronous Array functions\n\nStreamline extends the Array prototype with asynchronous variants of the EcmaScript 5 `forEach`, `map`, `filter`, `reduce`, ... functions. These asynchronous variants are postfixed with an underscore and they take an extra `_` argument (their callback too), but they are otherwise similar to the standard ES5 functions. Here is an example with the `map_` function:\n\n``` javascript\nfunction dirLines(dir, _) {\n  return fs.readdir(dir, _).map_(_, function(_, file) {\n    return fs.readFile(dir + '/' + file, 'utf8', _).split('\\n').length;\n  });\n}\n```\n\nParallelizing loops is easy: just pass the number of parallel operations as second argument to the call:\n\n``` javascript\nfunction dirLines(dir, _) {\n  // process 8 files in parallel\n  return fs.readdir(dir, _).map_(_, 8, function(_, file) {\n    return fs.readFile(dir + '/' + file, 'utf8', _).split('\\n').length;\n  });\n}\n```\n\nIf you don't want to limit the level of parallelism, just pass `-1`.\n\nSee the documentation of the [builtins module](https://github.com/Sage/streamlinejs/blob/master/lib/compiler/builtins.md) for details.\n\n<a name=\"exception-handling\">\n# Exception Handling\n\nStreamline lets you do your exception handling with the usual `try/catch` construct. The `finally` clause is also fully supported.\n\nStreamline overrides the `ex.stack` getter to give you complete comprehensive stacktrace information. In _callbacks_ and _generators_ modes you get two stack traces:\n\n* the _raw_ stack trace of the last callback.\n* the _async_ stack trace of the asynchronous calls that caused the exception.\n\nIn _fibers_ mode there is a single stack trace.\n\nNote: you must install the companion [galaxy-stack](https://github.com/bjouhier/galaxy-stack) package to get _async_ stack traces in _generators_ mode.\n\nException handling also works with futures and promises.\nIf a future throws an exception before you try to read its result, the exception is memorized by the future and you get it at the point where your try to read the future's result. \nFor example:\n\n``` javascript\ntry {\n  var n1 = countLines(badPath, !_);\n  var n2 = countLines(goodPath, !_);\n  setTimeout(_, 1000); // n1 fails, exception is memorized\n  return n1(_) - n2(_); // exception is thrown by n1(_) expression.\n} catch (ex) {\n  console.error(ex.stack); // exception caught here\n}\n```\n\n<a name=\"multiple-results\">\n# Callbacks with multiple results\n\nSome APIs return several results through their callback. For example:\n\n``` javascript\nrequest(options, function(err, response, body) {\n  // ...\n});\n```\n\nYou can get all the results by passing `[_]` instead of `_`:\n\n``` javascript\nvar results = request(options, [_]);\n// will be better with destructuring assignment.\nvar response = results[0];\nvar body = results[1];\n```\n\nNote: if you only need the first result you can pass `_`:\n\n``` javascript\nvar response = request(options, _);\n```\n\n<a name=\"coffee-script\">\n# CoffeeScript support\n\nCoffeeScript is fully supported. \n\nYou can even use language features which are not available in JavaScript. For example you can specify a default callback (see [#218](https://github.com/Sage/streamlinejs/issues/218) for full details):\n\n```coffeescript\nfn = (p1, p2, _ = (e) -> throw e if e) ->\n  # do something\n```\n\n<a name=\"fast-mode\">\n# Fast mode\n\nStreamline has a _fast_ mode which produces leaner and faster code at the expense of a few more keystrokes and a bit of extra care when writing the code.\n\nThis mode only applies to _fibers_ and _generators_ modes. It has no impact in _callbacks_ mode.\n\nFor details see the [fast mode wiki page](https://github.com/Sage/streamlinejs/wiki/Fast-mode)\n\n<a name=\"stream-wrappers\">\n# Stream Wrappers\n\nStreamline also provides _stream wrappers_ that simplify stream programming. These wrappers used to be included in the streamline npm package but they have now been moved to a separate [ez-streams](https://github.com/Sage/ez-streams) package.\n\n<a name=\"examples\">\n# Examples\n\nThe [tutorial](https://github.com/Sage/streamlinejs/blob/master/tutorial/tutorial.md) shows streamline.js in action on a simple _search aggregator_ application.\n\nThe [diskUsage](https://github.com/Sage/streamlinejs/blob/master/examples/diskUsage) examples show an asynchronous directory traversal that computes disk usage.\n\n<a name=\"online-demo\">\n# Online demo\n\nYou can see how streamline transforms the code by playing with the [online demo](http://sage.github.com/streamlinejs/examples/streamlineMe/streamlineMe.html).\n\n<a name=\"troubleshooting\">\n# Troubleshooting\n\nRead the [FAQ](https://github.com/Sage/streamlinejs/blob/master/FAQ.md).\n\nIf you don't find your answer in the FAQ, post to the [mailing list](http://groups.google.com/group/streamlinejs), or file an issue in [GitHub's issue tracking](https://github.com/Sage/streamlinejs/issues).\n\n<a name=\"related-packages\">\n# Related Packages\n\nThe following package contains a complete yet simple streaming API for streamline.js:\n\n* [ez-streams](https://github.com/Sage/ez-streams): easy streams, with array-like API (filter, map, reduce, foreach, some, every), transforms (json, csv and xml streaming parsers and formatters), parallelization, buffering, etc.\n\nThe following packages contain API wrappers for streamline.js:\n\n* [streamline-fs](https://github.com/Sage/streamline-fs): wrapper for node's `fs` module. It fixes the `fs.exists` call and it wraps the entire API for streamline's fast mode.\n* [streamline-streams](https://github.com/Sage/streamline-streams): historical streaming module for streamline. It implements the low level bits of the `ez-steams` module (see above). If you want a rich streaming APIs you should use `ez-streams` instead. \n* [streamline-mongodb](https://github.com/Sage/streamline-mongodb): wrappers for [mongodb](https://github.com/mongodb/node-mongodb-native)'s native node.js driver. You only need this wrapper if you use the _fast_ mode.\n\nThere are also some helper packages for [express](http://expressjs.com/):\n\n* [express-streamline](https://github.com/aseemk/express-streamline)\n* [streamline-express](https://github.com/sethyuan/streamline-express)\n\n\nThe following packages use streamline.js:\n\n* [streamline-require](https://github.com/Sage/streamline-require): a light and efficient _require_ infrastructure for modules in the browser.\n* [streamline-pdfkit](https://github.com/Sage/streamline-pdfkit): a fork of [pdfkit](https://github.com/devongovett/pdfkit) in which all the sync calls have been eliminated.\n* [streamline-zip](https://github.com/Sage/streamline-zip): a fork of [node-native-zip](https://github.com/janjongboom/node-native-zip) with async deflate.\n\n\n<a name=\"resources\">\n# Resources\n\nThe [tutorial](https://github.com/Sage/streamlinejs/blob/master/tutorial/tutorial.md) and [FAQ](https://github.com/Sage/streamlinejs/blob/master/FAQ.md) are must-reads for starters.\n\nThe API is documented [here](https://github.com/Sage/streamlinejs/blob/master/API.md).\n\nFor support and discussion, please join the [streamline.js mailing list](http://groups.google.com/group/streamlinejs).\n\n<a name=\"credits\">\n# Credits\n\nSee the [AUTHORS](https://github.com/Sage/streamlinejs/blob/master/AUTHORS) file.\n\nSpecial thanks to Marcel Laverdet who contributed the _fibers_ implementation and to Geoffry Song who contributed sourcemap support.\n\n<a name=\"license\">\n# License\n\nStreamline.js is licensed under the [MIT license](http://en.wikipedia.org/wiki/MIT_License).\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/Sage/streamlinejs/issues"
  },
  "_id": "streamline@0.10.12",
  "dist": {
    "shasum": "4c256bc16c3b6cb50b9e5400078326ac7b62bfba"
  },
  "_from": "streamline@~0.10 >=0.10.1",
  "_resolved": "https://registry.npmjs.org/streamline/-/streamline-0.10.12.tgz"
}
